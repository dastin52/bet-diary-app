// functions/api/telegram/webhook.ts

// --- TYPE DEFINITIONS ---
interface KVNamespace {
    put(key: string, value: string | ArrayBuffer | ReadableStream, options?: { expiration?: number; expirationTtl?: number; metadata?: any; }): Promise<void>;
    get(key: string, type?: "text" | "json" | "arrayBuffer" | "stream"): Promise<string | null | any>;
    delete(key: string): Promise<void>;
}

interface Env {
    BOT_STATE: KVNamespace;
    TELEGRAM_BOT_TOKEN: string;
}

interface EventContext<E> {
    request: Request;
    env: E;
}

type PagesFunction<E = unknown> = (context: EventContext<E>) => Response | Promise<Response>;

// Telegram API Types
interface TelegramUser { id: number; }
interface TelegramChat { id: number; }
interface TelegramMessage { message_id: number; from: TelegramUser; chat: TelegramChat; date: number; text?: string; }
interface TelegramCallbackQuery { id: string; from: TelegramUser; message: TelegramMessage; data?: string; }
interface TelegramUpdate { update_id: number; message?: TelegramMessage; callback_query?: TelegramCallbackQuery; }

// --- Re-importing necessary types from the main app ---
enum BetStatus { Pending = 'pending', Won = 'won', Lost = 'lost', Void = 'void', CashedOut = 'cashed_out' }
enum BetType { Single = 'single', Parlay = 'parlay', System = 'system' }
interface BetLeg { homeTeam: string; awayTeam: string; market: string; }
interface Bet { id: string; createdAt: string; event: string; legs: BetLeg[]; sport: string; bookmaker: string; betType: BetType; stake: number; odds: number; status: BetStatus; profit?: number; tags?: string[]; }
enum BankTransactionType { Deposit = 'deposit', Withdrawal = 'withdrawal', BetWin = 'bet_win', BetLoss = 'bet_loss', BetVoid = 'bet_void' }
interface BankTransaction { id: string; timestamp: string; type: BankTransactionType; amount: number; previousBalance: number; newBalance: number; description: string; betId?: string; }
interface User { email: string; nickname: string; password_hash: string; registeredAt: string; referralCode: string; buttercups: number; status: 'active' | 'blocked'; }

// FIX: Define missing Goal and UserData types to resolve compilation errors.
enum GoalMetric { Profit = 'profit', ROI = 'roi', WinRate = 'win_rate', BetCount = 'bet_count' }
enum GoalStatus { InProgress = 'in_progress', Achieved = 'achieved', Failed = 'failed' }
interface Goal { id: string; title: string; metric: GoalMetric; targetValue: number; currentValue: number; status: GoalStatus; createdAt: string; deadline: string; scope: { type: 'sport' | 'betType' | 'tag' | 'all'; value?: string; }; }

// This structure holds all data for a user, which is stored as a single JSON blob in KV.
interface UserData {
    bets: Bet[];
    bankroll: number;
    goals: Goal[];
    bankHistory: BankTransaction[];
}
// --- End of re-imported types ---

// App-specific Types for bot state
type AddBetData = Partial<Omit<Bet, 'id' | 'createdAt' | 'event'>>;
type ConversationStep =
    | 'awaiting_nickname' | 'awaiting_email' | 'awaiting_password'
    | 'add_bet_awaiting_event' | 'add_bet_awaiting_market' | 'add_bet_awaiting_stake_odds' | 'add_bet_awaiting_status'
    | 'update_bet_awaiting_status'
    | 'manage_bank_awaiting_deposit' | 'manage_bank_awaiting_withdrawal';

interface ConversationState {
    step: ConversationStep;
    data: {
        nickname?: string;
        email?: string;
        bet?: AddBetData;
        betId?: string; // For updating status
    };
}

// --- CONSTANTS & KEYBOARDS ---
const SPORTS = ['–§—É—Ç–±–æ–ª', '–ë–∞—Å–∫–µ—Ç–±–æ–ª', '–¢–µ–Ω–Ω–∏—Å', '–•–æ–∫–∫–µ–π', '–ú–ú–ê', '–ö–∏–±–µ—Ä—Å–ø–æ—Ä—Ç'];
const MARKETS_BY_SPORT: { [key: string]: string[] } = {
  '–§—É—Ç–±–æ–ª': ['–ü1', 'X', '–ü2', '–û–±–µ –∑–∞–±—å—é—Ç - –î–∞', '–¢–æ—Ç–∞–ª > 2.5', '–¢–æ—Ç–∞–ª < 2.5'],
  '–ë–∞—Å–∫–µ—Ç–±–æ–ª': ['–ü1 (—Å –û–¢)', '–ü2 (—Å –û–¢)', '–¢–æ—Ç–∞–ª > 220.5', '–¢–æ—Ç–∞–ª < 220.5'],
  '–¢–µ–Ω–Ω–∏—Å': ['–ü1', '–ü2', '–¢–æ—Ç–∞–ª –ø–æ –≥–µ–π–º–∞–º > 22.5', '–¢–æ—Ç–∞–ª –ø–æ –≥–µ–π–º–∞–º < 22.5'],
  '–•–æ–∫–∫–µ–π': ['–ü1 (–≤–∫–ª. –û–¢)', '–ü2 (–≤–∫–ª. –û–¢)', '–¢–æ—Ç–∞–ª > 5.5', '–¢–æ—Ç–∞–ª < 5.5'],
  '–ú–ú–ê': ['–ü1', '–ü2', '–¢–æ—Ç–∞–ª —Ä–∞—É–Ω–¥–æ–≤ > 1.5', '–ë–æ–π –ø—Ä–æ–π–¥–µ—Ç –≤—Å—é –¥–∏—Å—Ç–∞–Ω—Ü–∏—é'],
  '–ö–∏–±–µ—Ä—Å–ø–æ—Ä—Ç': ['–ü1', '–ü2', '–¢–æ—Ç–∞–ª –∫–∞—Ä—Ç > 2.5', '–§–æ—Ä–∞ 1 (-1.5)'],
};

const welcomeKeyboard = {
    inline_keyboard: [
        [{ text: "‚úçÔ∏è –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –∞–∫–∫–∞—É–Ω—Ç", callback_data: "register" }],
        [{ text: "üîó –ü—Ä–∏–≤—è–∑–∞—Ç—å –∞–∫–∫–∞—É–Ω—Ç", callback_data: "link_account" }]
    ]
};
const mainMenuKeyboard = {
    inline_keyboard: [
        [{ text: "üìù –î–æ–±–∞–≤–∏—Ç—å —Å—Ç–∞–≤–∫—É", callback_data: "add_bet" }],
        [{ text: "üìà –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç–∞–≤–∫–∞–º–∏", callback_data: "manage_bets" }],
        [{ text: "üìä –ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏", callback_data: "view_stats" }],
        [{ text: "üí∞ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–∞–Ω–∫–æ–º", callback_data: "manage_bank" }],
    ]
};
const betManagementKeyboard = {
    inline_keyboard: [
        [{ text: "üîÑ –ò–∑–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ç—É—Å —Å—Ç–∞–≤–∫–∏", callback_data: "update_bet_status_select" }],
        [{ text: "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data: "main_menu" }],
    ]
};
const cancelKeyboard = { inline_keyboard: [[{ text: "‚ùå –û—Ç–º–µ–Ω–∞", callback_data: "cancel_action" }]] };
const statsKeyboard = { inline_keyboard: [[{ text: "üìà –ó–∞ –Ω–µ–¥–µ–ª—é", callback_data: "view_stats_week" }, { text: "üìä –ó–∞ –º–µ—Å—è—Ü", callback_data: "view_stats_month" }]] };
const bankKeyboard = { inline_keyboard: [[{ text: "üì• –í–Ω–µ—Å—Ç–∏ –¥–µ–ø–æ–∑–∏—Ç", callback_data: "deposit" }, { text: "üì§ –°–¥–µ–ª–∞—Ç—å –≤—ã–≤–æ–¥", callback_data: "withdraw" }]] };
const addBetStatusKeyboard = {
    inline_keyboard: [
        [{ text: "‚è≥ –í –æ–∂–∏–¥–∞–Ω–∏–∏", callback_data: `add_bet_set_status:${BetStatus.Pending}` }],
        [{ text: "‚úÖ –í—ã–∏–≥—Ä—ã—à", callback_data: `add_bet_set_status:${BetStatus.Won}` }, { text: "‚ùå –ü—Ä–æ–∏–≥—Ä—ã—à", callback_data: `add_bet_set_status:${BetStatus.Lost}` }],
        [{ text: "‚Ü©Ô∏è –í–æ–∑–≤—Ä–∞—Ç", callback_data: `add_bet_set_status:${BetStatus.Void}` }],
    ]
};

// --- TELEGRAM API HELPER ---
const telegramApi = async (token: string, methodName: string, body: object) => {
    try {
        const response = await fetch(`https://api.telegram.org/bot${token}/${methodName}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
        });
        if (!response.ok) {
            const result = await response.json();
            console.error(`Telegram API error (${methodName}):`, result.description);
        }
        return response;
    } catch (error) {
        console.error(`Network error calling Telegram API (${methodName}):`, error instanceof Error ? error.message : String(error));
        return new Response('Network error', { status: 500 });
    }
};

// A mock hashing function.
const mockHash = (password: string) => `hashed_${password}`;

// --- KV & DATA HELPERS ---
const getUserEmailFromTgId = (kv: KVNamespace, tgId: number): Promise<string | null> => kv.get(`user:tg:${tgId}`);
const getState = async (kv: KVNamespace, tgId: number): Promise<ConversationState | null> => {
    const stateJson = await kv.get(`state:tg:${tgId}`);
    return stateJson ? JSON.parse(stateJson) : null;
};
const setState = (kv: KVNamespace, tgId: number, state: ConversationState | null): Promise<void> => {
    if (state === null) {
        return kv.delete(`state:tg:${tgId}`);
    }
    return kv.put(`state:tg:${tgId}`, JSON.stringify(state), { expirationTtl: 900 }); // State expires in 15 mins
};
const getUserData = async (kv: KVNamespace, email: string): Promise<UserData> => {
    const dataJson = await kv.get(`data:user:${email}`);
    if (dataJson) {
        return JSON.parse(dataJson);
    }
    // FIX: Add `goals` to the initial user data object to match the UserData type.
    const newUser: UserData = { bankroll: 10000, bets: [], goals: [], bankHistory: [] };
    await saveUserData(kv, email, newUser);
    return newUser;
};
const saveUserData = (kv: KVNamespace, email: string, data: UserData): Promise<void> => kv.put(`data:user:${email}`, JSON.stringify(data));

// --- BUSINESS LOGIC HELPERS ---
const calculateProfit = (bet: { status: BetStatus, stake: number, odds: number, profit?: number }): number => {
    switch (bet.status) {
      case BetStatus.Won: return bet.stake * (bet.odds - 1);
      case BetStatus.Lost: return -bet.stake;
      case BetStatus.Void: return 0;
      default: return 0;
    }
};
const generateEventString = (legs: BetLeg[], betType: BetType, sport: string): string => {
    if (!legs || legs.length === 0) return '–ü—É—Å—Ç–æ–µ —Å–æ–±—ã—Ç–∏–µ';
    if (betType === BetType.Parlay) return `–≠–∫—Å–ø—Ä–µ—Å—Å (${legs.length} —Å–æ–±—ã—Ç–∏–π)`;
    const leg = legs[0];
    const eventName = ['–¢–µ–Ω–Ω–∏—Å', '–ë–æ–∫—Å', '–ú–ú–ê'].includes(sport) ? `${leg.homeTeam} - ${leg.awayTeam}` : `${leg.homeTeam} vs ${leg.awayTeam}`;
    return `${eventName} - ${leg.market}`;
};

async function addBetToUserData(kv: KVNamespace, email: string, betData: AddBetData) {
    const userData = await getUserData(kv, email);
    const newBet: Bet = {
      ...(betData as Omit<Bet, 'id' | 'createdAt' | 'event'>),
      id: new Date().toISOString() + Math.random(),
      createdAt: new Date().toISOString(),
      event: generateEventString(betData.legs!, betData.betType!, betData.sport!),
    };
    
    if (newBet.status !== BetStatus.Pending) {
        newBet.profit = calculateProfit(newBet);
        if(newBet.profit !== 0) {
            const type = newBet.profit > 0 ? BankTransactionType.BetWin : BankTransactionType.BetLoss;
            await addBankTransactionToUserData(kv, email, newBet.profit, type, `–°—Ç–∞–≤–∫–∞: ${newBet.event}`, userData);
        }
    } else {
        userData.bets.unshift(newBet); // Add to beginning
        await saveUserData(kv, email, userData);
    }
}

async function addBankTransactionToUserData(kv: KVNamespace, email: string, amount: number, type: BankTransactionType, description: string, existingUserData?: UserData) {
    const userData = existingUserData || await getUserData(kv, email);
    const newTransaction: BankTransaction = {
        id: new Date().toISOString() + Math.random(),
        timestamp: new Date().toISOString(),
        type,
        amount,
        previousBalance: userData.bankroll,
        newBalance: userData.bankroll + amount,
        description,
    };
    userData.bankroll += amount;
    userData.bankHistory.unshift(newTransaction);
    await saveUserData(kv, email, userData);
}

// --- MAIN FUNCTION HANDLER ---
export const onRequestPost: PagesFunction<Env> = async ({ request, env }) => {
    const requestClone = request.clone();
    if (!env.TELEGRAM_BOT_TOKEN || !env.BOT_STATE) {
        console.error("FATAL: Environment variables or KV bindings are not set.");
        return new Response('OK');
    }
    const token = env.TELEGRAM_BOT_TOKEN;
    const kv = env.BOT_STATE;

    try {
        const update = await request.json() as TelegramUpdate;
        console.log("Received update:", update.update_id);
        const fromId = update.message?.from.id || update.callback_query?.from.id;
        const chatId = update.message?.chat.id || update.callback_query?.message.chat.id;
        if (!fromId || !chatId) return new Response('OK');

        // --- Handle Callback Queries (Button Presses) ---
        if (update.callback_query) {
            const { id: callbackQueryId, data: callbackData } = update.callback_query;
            await telegramApi(token, 'answerCallbackQuery', { callback_query_id: callbackQueryId });

            const state = await getState(kv, fromId);

            if (callbackData === 'cancel_action') {
                await setState(kv, fromId, null);
                await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup: mainMenuKeyboard });
                return new Response('OK');
            }
            if (callbackData === 'main_menu') {
                await setState(kv, fromId, null);
                await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup: mainMenuKeyboard });
                return new Response('OK');
            }
            
            // Add Bet Flow
            if (callbackData?.startsWith('add_bet_sport_')) {
                const sport = callbackData.replace('add_bet_sport_', '');
                await setState(kv, fromId, { step: 'add_bet_awaiting_event', data: { bet: { sport, betType: BetType.Single, legs: [{ homeTeam: '', awayTeam: '', market: '' }] } } });
                await telegramApi(token, 'sendMessage', { chat_id: chatId, text: `–í—ã–±—Ä–∞–Ω —Å–ø–æ—Ä—Ç: ${sport}.\n\n–í–≤–µ–¥–∏—Ç–µ —Å–æ–±—ã—Ç–∏–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "–†–µ–∞–ª –ú–∞–¥—Ä–∏–¥ - –ë–∞—Ä—Å–µ–ª–æ–Ω–∞"):`, reply_markup: cancelKeyboard });
                return new Response('OK');
            }
            if (callbackData?.startsWith('add_bet_market_')) {
                const market = callbackData.replace('add_bet_market_', '');
                if (state?.step === 'add_bet_awaiting_market' && state.data.bet) {
                    state.data.bet.legs![0].market = market;
                    state.step = 'add_bet_awaiting_stake_odds';
                    await setState(kv, fromId, state);
                    await telegramApi(token, 'sendMessage', { chat_id: chatId, text: `–í—ã–±—Ä–∞–Ω –∏—Å—Ö–æ–¥: ${market}.\n\n–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Å—Ç–∞–≤–∫–∏ –∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª (–Ω–∞–ø—Ä–∏–º–µ—Ä, "1000 2.15"):`, reply_markup: cancelKeyboard });
                }
                return new Response('OK');
            }
            if (callbackData?.startsWith('add_bet_set_status:')) {
                const status = callbackData.replace('add_bet_set_status:', '') as BetStatus;
                if (state?.step === 'add_bet_awaiting_status' && state.data.bet) {
                    state.data.bet.status = status;
                    const userEmail = await getUserEmailFromTgId(kv, fromId);
                    if (userEmail) {
                        await addBetToUserData(kv, userEmail, state.data.bet);
                        await setState(kv, fromId, null);
                        await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "‚úÖ –°—Ç–∞–≤–∫–∞ —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–∞!", reply_markup: mainMenuKeyboard });
                    }
                }
                return new Response('OK');
            }

            // Update Bet Status Flow
            if (callbackData === 'update_bet_status_select') {
                const userEmail = await getUserEmailFromTgId(kv, fromId);
                if (userEmail) {
                    const userData = await getUserData(kv, userEmail);
                    const pendingBets = userData.bets.filter(b => b.status === BetStatus.Pending).slice(0, 5); // Get last 5 pending
                    if (pendingBets.length === 0) {
                        await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–£ –≤–∞—Å –Ω–µ—Ç —Å—Ç–∞–≤–æ–∫ –≤ –æ–∂–∏–¥–∞–Ω–∏–∏.", reply_markup: mainMenuKeyboard });
                        return new Response('OK');
                    }
                    const betButtons = pendingBets.map(bet => ([{ text: `üìù ${bet.event.substring(0, 30)}...`, callback_data: `update_bet_status:${bet.id}` }]));
                    betButtons.push([{ text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'main_menu' }]);
                    await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∞–≤–∫—É –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:", reply_markup: { inline_keyboard: betButtons } });
                }
                return new Response('OK');
            }
            if (callbackData?.startsWith('update_bet_status:')) {
                const betId = callbackData.replace('update_bet_status:', '');
                await setState(kv, fromId, { step: 'update_bet_awaiting_status', data: { betId } });
                const keyboard = { inline_keyboard: [
                    [{ text: '‚úÖ –í—ã–∏–≥—Ä—ã—à', callback_data: `set_bet_status:${betId}:${BetStatus.Won}` }, { text: '‚ùå –ü—Ä–æ–∏–≥—Ä—ã—à', callback_data: `set_bet_status:${betId}:${BetStatus.Lost}` }],
                    [{ text: '‚Ü©Ô∏è –í–æ–∑–≤—Ä–∞—Ç', callback_data: `set_bet_status:${betId}:${BetStatus.Void}` }],
                    [{ text: '‚¨ÖÔ∏è –ù–∞–∑–∞–¥', callback_data: 'update_bet_status_select' }]
                ]};
                await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–£–∫–∞–∂–∏—Ç–µ –Ω–æ–≤—ã–π —Å—Ç–∞—Ç—É—Å –¥–ª—è —Å—Ç–∞–≤–∫–∏:", reply_markup: keyboard });
                return new Response('OK');
            }
            if (callbackData?.startsWith('set_bet_status:')) {
                const [, betId, newStatusStr] = callbackData.split(':');
                const newStatus = newStatusStr as BetStatus;
                const userEmail = await getUserEmailFromTgId(kv, fromId);
                if (userEmail && betId && newStatus) {
                    const userData = await getUserData(kv, userEmail);
                    const betIndex = userData.bets.findIndex(b => b.id === betId);
                    if (betIndex > -1) {
                        const bet = userData.bets[betIndex];
                        bet.status = newStatus;
                        bet.profit = calculateProfit(bet);
                        userData.bets[betIndex] = bet;
                        
                        let profitText = '';
                        if (bet.profit !== 0) {
                             const type = bet.profit > 0 ? BankTransactionType.BetWin : BankTransactionType.BetLoss;
                             const description = `–°—Ç–∞–≤–∫–∞ ${newStatus === BetStatus.Won ? '–≤—ã–∏–≥—Ä–∞–ª–∞' : '–ø—Ä–æ–∏–≥—Ä–∞–ª–∞'}: ${bet.event}`;
                             await addBankTransactionToUserData(kv, userEmail, bet.profit, type, description, userData);
                             profitText = `\n${bet.profit > 0 ? 'üí∞ –í–∞—à –±–∞–Ω–∫ –ø–æ–ø–æ–ª–Ω–µ–Ω –Ω–∞' : 'üí∏ –í–∞—à –±–∞–Ω–∫ —É–º–µ–Ω—å—à–µ–Ω –Ω–∞'} ${Math.abs(bet.profit).toFixed(2)} ‚ÇΩ.`;
                        } else {
                             await saveUserData(kv, userEmail, userData);
                        }
                        
                        await setState(kv, fromId, null);
                        await telegramApi(token, 'sendMessage', { chat_id: chatId, text: `‚úÖ –°—Ç–∞—Ç—É—Å —Å—Ç–∞–≤–∫–∏ "${bet.event}" –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ "${newStatus}".${profitText}`, reply_markup: mainMenuKeyboard });
                    }
                }
                return new Response('OK');
            }

            // Main Menu actions
            switch (callbackData) {
                case 'register':
                    await setState(kv, fromId, { step: 'awaiting_nickname', data: {} });
                    await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–ö–∞–∫–æ–π —É –≤–∞—Å –±—É–¥–µ—Ç –Ω–∏–∫–Ω–µ–π–º? (–º–∏–Ω. 3 —Å–∏–º–≤–æ–ª–∞)" });
                    break;
                case 'link_account':
                    await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ 6-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥ –Ω–∞ —Å–∞–π—Ç–µ ('–ù–∞—Å—Ç—Ä–æ–π–∫–∏' ‚ûî '–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Telegram') –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –µ–≥–æ –º–Ω–µ." });
                    break;
                case 'add_bet':
                    const sportButtons = SPORTS.map(sport => ({ text: sport, callback_data: `add_bet_sport_${sport}` }));
                    const keyboard = { inline_keyboard: [sportButtons.slice(0, 3), sportButtons.slice(3, 6), [{ text: "‚ùå –û—Ç–º–µ–Ω–∞", callback_data: "cancel_action" }]] };
                    await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–í—ã–±–µ—Ä–∏—Ç–µ –≤–∏–¥ —Å–ø–æ—Ä—Ç–∞:", reply_markup: keyboard });
                    break;
                case 'manage_bets':
                    await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç–∞–≤–∫–∞–º–∏:", reply_markup: betManagementKeyboard });
                    break;
                case 'view_stats':
                    await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–ó–∞ –∫–∞–∫–æ–π –ø–µ—Ä–∏–æ–¥ –ø–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É?", reply_markup: statsKeyboard });
                    break;
                case 'manage_bank':
                     await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup: bankKeyboard });
                    break;
                case 'deposit':
                     await setState(kv, fromId, { step: 'manage_bank_awaiting_deposit', data: {} });
                     await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è:", reply_markup: cancelKeyboard });
                    break;
                case 'withdraw':
                     await setState(kv, fromId, { step: 'manage_bank_awaiting_withdrawal', data: {} });
                     await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –¥–ª—è –≤—ã–≤–æ–¥–∞:", reply_markup: cancelKeyboard });
                    break;
                case 'view_stats_week':
                case 'view_stats_month':
                     const userEmailForStats = await getUserEmailFromTgId(kv, fromId);
                     if (userEmailForStats) {
                        const userData = await getUserData(kv, userEmailForStats);
                        const period = callbackData.includes('week') ? 7 : 30;
                        const startDate = new Date(Date.now() - period * 24 * 60 * 60 * 1000);
                        const periodBets = userData.bets.filter(b => new Date(b.createdAt) >= startDate && b.status !== BetStatus.Pending);
                        
                        if (periodBets.length === 0) {
                             await telegramApi(token, 'sendMessage', { chat_id: chatId, text: `–ó–∞ —ç—Ç–æ—Ç –ø–µ—Ä–∏–æ–¥ –Ω–µ—Ç —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—ã—Ö —Å—Ç–∞–≤–æ–∫.` });
                             return new Response('OK');
                        }

                        const totalStaked = periodBets.reduce((acc, bet) => acc + bet.stake, 0);
                        const totalProfit = periodBets.reduce((acc, bet) => acc + (calculateProfit(bet) ?? 0), 0);
                        const roi = totalStaked > 0 ? (totalProfit / totalStaked) * 100 : 0;
                        const winRate = periodBets.filter(b => b.status === BetStatus.Won).length / periodBets.filter(b => b.status !== BetStatus.Void).length * 100 || 0;

                        const summary = `üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ ${period === 7 ? '–Ω–µ–¥–µ–ª—é' : '–º–µ—Å—è—Ü'}*\n\n` +
                                        `üí∞ *–ü—Ä–æ—Ñ–∏—Ç:* ${totalProfit.toFixed(2)} ‚ÇΩ\n` +
                                        `üìà *ROI:* ${roi.toFixed(2)}%\n` +
                                        `üéØ *–ü—Ä–æ—Ö–æ–¥–∏–º–æ—Å—Ç—å:* ${winRate.toFixed(1)}%\n` +
                                        `üìã *–í—Å–µ–≥–æ —Å—Ç–∞–≤–æ–∫:* ${periodBets.length}`;
                        
                        await telegramApi(token, 'sendMessage', { chat_id: chatId, text: summary, parse_mode: 'Markdown' });
                     }
                    break;
            }
            return new Response('OK');
        }

        // --- Handle Text Messages ---
        if (update.message?.text) {
            const messageText = update.message.text.trim();
            const state = await getState(kv, fromId);
            
            // Handle Conversation Steps
            if (state) {
                 const userEmail = await getUserEmailFromTgId(kv, fromId);
                 switch (state.step) {
                    case 'add_bet_awaiting_event':
                        const [homeTeam, awayTeam] = messageText.split(/[-vs_]/).map(s => s.trim());
                        if (!homeTeam || !awayTeam) {
                            await telegramApi(token, 'sendMessage', { chat_id: chatId, text: '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Å–æ–±—ã—Ç–∏–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ "–ö–æ–º–∞–Ω–¥–∞ 1 - –ö–æ–º–∞–Ω–¥–∞ 2".' });
                            return new Response('OK');
                        }
                        state.data.bet!.legs![0].homeTeam = homeTeam;
                        state.data.bet!.legs![0].awayTeam = awayTeam;
                        state.step = 'add_bet_awaiting_market';
                        await setState(kv, fromId, state);
                        const markets = MARKETS_BY_SPORT[state.data.bet!.sport!] || [];
                        const marketButtons = markets.map(m => ({ text: m, callback_data: `add_bet_market_${m}`}));
                        const marketKeyboard = { inline_keyboard: [marketButtons.slice(0,3), marketButtons.slice(3,6), [{ text: "‚ùå –û—Ç–º–µ–Ω–∞", callback_data: "cancel_action" }]] };
                        await telegramApi(token, 'sendMessage', { chat_id: chatId, text: `–°–æ–±—ã—Ç–∏–µ: ${homeTeam} - ${awayTeam}.\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∏—Å—Ö–æ–¥:`, reply_markup: marketKeyboard });
                        break;
                    case 'add_bet_awaiting_stake_odds':
                        const [stakeStr, oddsStr] = messageText.split(/\s+/);
                        const stake = parseFloat(stakeStr);
                        const odds = parseFloat(oddsStr);
                        if (isNaN(stake) || isNaN(odds) || stake <= 0 || odds <= 1) {
                            await telegramApi(token, 'sendMessage', { chat_id: chatId, text: '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª (–Ω–∞–ø—Ä–∏–º–µ—Ä, "1000 2.15").' });
                            return new Response('OK');
                        }
                        state.data.bet!.stake = stake;
                        state.data.bet!.odds = odds;
                        state.step = 'add_bet_awaiting_status';
                        await setState(kv, fromId, state);
                        await telegramApi(token, 'sendMessage', { chat_id: chatId, text: '–ö–∞–∫–æ–π —Å—Ç–∞—Ç—É—Å —É —ç—Ç–æ–π —Å—Ç–∞–≤–∫–∏?', reply_markup: addBetStatusKeyboard });
                        break;
                    case 'manage_bank_awaiting_deposit':
                    case 'manage_bank_awaiting_withdrawal':
                        const amount = parseFloat(messageText);
                        if (isNaN(amount) || amount <= 0) {
                            await telegramApi(token, 'sendMessage', { chat_id: chatId, text: '–ù–µ–≤–µ—Ä–Ω–∞—è —Å—É–º–º–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.' });
                            return new Response('OK');
                        }
                        if (userEmail) {
                            const isDeposit = state.step === 'manage_bank_awaiting_deposit';
                            await addBankTransactionToUserData(kv, userEmail, isDeposit ? amount : -amount, isDeposit ? BankTransactionType.Deposit : BankTransactionType.Withdrawal, isDeposit ? "–î–µ–ø–æ–∑–∏—Ç —á–µ—Ä–µ–∑ Telegram" : "–í—ã–≤–æ–¥ —á–µ—Ä–µ–∑ Telegram");
                            await setState(kv, fromId, null);
                            await telegramApi(token, 'sendMessage', { chat_id: chatId, text: `‚úÖ –ë–∞–ª–∞–Ω—Å —É—Å–ø–µ—à–Ω–æ ${isDeposit ? '–ø–æ–ø–æ–ª–Ω–µ–Ω' : '–æ–±–Ω–æ–≤–ª–µ–Ω'}!`, reply_markup: mainMenuKeyboard });
                        }
                        break;
                    case 'awaiting_nickname':
                         if (messageText.length < 3) {
                            await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–ù–∏–∫–Ω–µ–π–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 3 —Å–∏–º–≤–æ–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞." });
                            return new Response('OK');
                         }
                         state.data.nickname = messageText;
                         state.step = 'awaiting_email';
                         await setState(kv, fromId, state);
                         await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à email:" });
                        break;
                    case 'awaiting_email':
                        if (!/^\S+@\S+\.\S+$/.test(messageText)) {
                            await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç email. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞." });
                            return new Response('OK');
                        }
                        state.data.email = messageText;
                        state.step = 'awaiting_password';
                        await setState(kv, fromId, state);
                        await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–¢–µ–ø–µ—Ä—å –ø—Ä–∏–¥—É–º–∞–π—Ç–µ –ø–∞—Ä–æ–ª—å (–º–∏–Ω. 6 —Å–∏–º–≤–æ–ª–æ–≤):" });
                        break;
                    case 'awaiting_password':
                        if (messageText.length < 6) {
                            await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–ü–∞—Ä–æ–ª—å —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ (–º–∏–Ω. 6 —Å–∏–º–≤–æ–ª–æ–≤)." });
                            return new Response('OK');
                        }
                        const { nickname, email } = state.data;
                        const password_hash = mockHash(messageText);
                        
                        const newUser = { email, nickname, password_hash, registeredAt: new Date().toISOString(), referralCode: `${nickname!.toUpperCase().replace(/\s/g, '')}${Date.now().toString().slice(-4)}`, buttercups: 0, status: 'active' };
                        await kv.put(`user:profile:${email}`, JSON.stringify(newUser));
                        await kv.put(`user:tg:${fromId}`, email!);
                        
                        await addBankTransactionToUserData(kv, email!, 10000, BankTransactionType.Deposit, "–ù–∞—á–∞–ª—å–Ω—ã–π –±–∞–Ω–∫ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏");

                        await setState(kv, fromId, null);
                        await telegramApi(token, 'sendMessage', { chat_id: chatId, text: `üéâ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –í–∞—à –∞–∫–∫–∞—É–Ω—Ç –¥–ª—è ${email} —Å–æ–∑–¥–∞–Ω –∏ –ø—Ä–∏–≤—è–∑–∞–Ω.`, reply_markup: mainMenuKeyboard });
                        break;
                }
                return new Response('OK');
            }

            // --- Handle Commands & Standard Messages ---
            switch (messageText) {
                case '/start':
                    const userEmail = await getUserEmailFromTgId(kv, fromId);
                    if (userEmail) {
                        await telegramApi(token, 'sendMessage', { chat_id: chatId, text: `–° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º!`, reply_markup: mainMenuKeyboard });
                    } else {
                        await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –î–Ω–µ–≤–Ω–∏–∫ –°—Ç–∞–≤–æ–∫!", reply_markup: welcomeKeyboard });
                    }
                    break;
                case '/getcode':
                     const emailForCode = await getUserEmailFromTgId(kv, fromId);
                     if (emailForCode) {
                         const code = Math.floor(100000 + Math.random() * 900000).toString();
                         await kv.put(`web_auth_code:${code}`, emailForCode, { expirationTtl: 120 }); // 2 minute expiry
                         await telegramApi(token, 'sendMessage', { chat_id: chatId, text: `üîë –í–∞—à –≤—Ä–µ–º–µ–Ω–Ω—ã–π –∫–æ–¥ –¥–ª—è –≤—Ö–æ–¥–∞ –Ω–∞ —Å–∞–π—Ç: *${code}*\n\n–û–Ω –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 2 –º–∏–Ω—É—Ç—ã.`, parse_mode: 'Markdown' });
                     } else {
                         await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –Ω–∞—á–∞–ª–∞." });
                     }
                    break;
                case '/ping':
                    await telegramApi(token, 'sendMessage', { chat_id: chatId, text: 'Pong!' });
                    break;
                case '/stats':
                    const userEmailForStatsCmd = await getUserEmailFromTgId(kv, fromId);
                    if (userEmailForStatsCmd) {
                         await telegramApi(token, 'sendMessage', { chat_id: chatId, text: `‚úÖ –í—ã –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –∫–∞–∫ ${userEmailForStatsCmd}.\n\n–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å—Ç–∞–≤–æ–∫ —á–µ—Ä–µ–∑ Telegram –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.` });
                    } else {
                         await telegramApi(token, 'sendMessage', { chat_id: chatId, text: '‚ùå –í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã. –°–Ω–∞—á–∞–ª–∞ –ø—Ä–∏–≤—è–∂–∏—Ç–µ –∞–∫–∫–∞—É–Ω—Ç.' });
                    }
                    break;
                default:
                    if (/^\d{6}$/.test(messageText)) { // Handle 6-digit auth code
                        const email = await kv.get(`authcode:${messageText}`);
                        if (email) {
                            await kv.put(`user:tg:${fromId}`, email);
                            await kv.delete(`authcode:${messageText}`);
                            await telegramApi(token, 'sendMessage', { chat_id: chatId, text: `‚úÖ –ê–∫–∫–∞—É–Ω—Ç –¥–ª—è ${email} —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–≤—è–∑–∞–Ω!`, reply_markup: mainMenuKeyboard });
                        } else {
                            await telegramApi(token, 'sendMessage', { chat_id: chatId, text: `‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∏–ª–∏ –∏—Å—Ç–µ–∫—à–∏–π –∫–æ–¥.` });
                        }
                    } else {
                        await telegramApi(token, 'sendMessage', { chat_id: chatId, text: "–Ø –Ω–µ –ø–æ–Ω—è–ª –∫–æ–º–∞–Ω–¥—É. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏." });
                    }
                    break;
            }
        }

    } catch (e: any) {
        const errorBody = await requestClone.text();
        console.error("--- UNHANDLED FATAL ERROR IN WEBHOOK ---");
        console.error("Message:", e.message);
        console.error("Stack:", e.stack);
        console.error("Request Body:", errorBody);
    }
    
    return new Response('OK');
};