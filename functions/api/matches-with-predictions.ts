// functions/api/matches-with-predictions.ts
import { Env, SharedPrediction } from '../telegram/types';

interface EventContext {
    request: Request;
    env: Env;
}

export const onRequestGet = async ({ request, env }: EventContext): Promise<Response> => {
    const url = new URL(request.url);
    const sport = url.searchParams.get('sport');

    if (!sport) {
        return new Response(JSON.stringify({ error: 'Sport parameter is required' }), {
            status: 400,
            headers: { 'Content-Type': 'application/json' },
        });
    }

    try {
        // The key is now simple, as the cron job is the single source of truth.
        const cacheKey = `central_predictions:${sport}`;
        
        const cachedData = await env.BOT_STATE.get(cacheKey, { type: 'json' });

        if (cachedData) {
            // Data is pre-generated by the cron job, return it immediately.
            return new Response(JSON.stringify(cachedData), {
                status: 200,
                headers: { 'Content-Type': 'application/json', 'X-Cache': 'HIT' },
            });
        } else {
            // If cron hasn't run yet or there was an error, return empty array.
            // The frontend is designed to handle this gracefully.
            console.warn(`[API] No pre-generated data found for sport: ${sport}. Cron job might not have run yet.`);
            return new Response(JSON.stringify([]), {
                status: 200,
                headers: { 'Content-Type': 'application/json', 'X-Cache': 'MISS' },
            });
        }

    } catch (error) {
        console.error(`Error in /api/matches-with-predictions for sport ${sport}:`, error);
        return new Response(JSON.stringify({ error: 'Failed to fetch predictions.' }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' },
        });
    }
};