// functions/telegram/analytics.ts
import { BetStatus, UserState } from './types';

export interface AnalyticsData {
    bankroll: number;
    totalProfit: number;
    roi: number;
    winRate: number;
    betCount: number;
    wonBetsCount: number;
    lostBetsCount: number;
    turnover: number;
    profitBySport: { sport: string; profit: number; roi: number; count: number }[];
}

export function calculateAnalytics(state: UserState): AnalyticsData {
    const settledBets = state.bets.filter(b => b.status !== BetStatus.Pending);
    const totalStaked = settledBets.reduce((acc, bet) => acc + bet.stake, 0);
    const totalProfit = settledBets.reduce((acc, bet) => acc + (bet.profit ?? 0), 0);
    const roi = totalStaked > 0 ? (totalProfit / totalStaked) * 100 : 0;
    const betCount = settledBets.length;
    const wonBets = settledBets.filter(b => b.status === BetStatus.Won);
    const lostBetsCount = settledBets.filter(b => b.status === BetStatus.Lost).length;
    const nonVoidBets = settledBets.filter(b => b.status !== BetStatus.Void);
    const winRate = nonVoidBets.length > 0 ? (wonBets.length / nonVoidBets.length) * 100 : 0;
    
    const statsBySport = settledBets.reduce((acc: Record<string, { profit: number, staked: number, count: number }>, bet) => {
        if (!acc[bet.sport]) acc[bet.sport] = { profit: 0, staked: 0, count: 0 };
        acc[bet.sport].profit += bet.profit ?? 0;
        acc[bet.sport].staked += bet.stake;
        acc[bet.sport].count += 1;
        return acc;
    }, {});

    return {
        bankroll: state.bankroll,
        totalProfit,
        roi,
        winRate,
        betCount,
        wonBetsCount: wonBets.length,
        lostBetsCount,
        turnover: totalStaked,
        // FIX: Rewrite map function without spread to avoid potential type inference issues.
        profitBySport: Object.entries(statsBySport).map(([sport, data]) => ({ 
            sport, 
            profit: data.profit, 
            count: data.count, 
            roi: data.staked > 0 ? (data.profit / data.staked) * 100 : 0
        })),
    };
}

export function formatShortReportText(analytics: AnalyticsData): string {
    const profitSign = analytics.totalProfit >= 0 ? '+' : '';
    return `*üìä –í–∞—à–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞*
    
- üí∞ *–¢–µ–∫—É—â–∏–π –±–∞–Ω–∫:* ${analytics.bankroll.toFixed(2)} ‚ÇΩ
- ${analytics.totalProfit >= 0 ? 'üìà' : 'üìâ'} *–û–±—â–∞—è –ø—Ä–∏–±—ã–ª—å:* ${profitSign}${analytics.totalProfit.toFixed(2)} ‚ÇΩ
- üéØ *ROI:* ${analytics.roi.toFixed(2)}%
- üîÑ *–û–±–æ—Ä–æ—Ç:* ${analytics.turnover.toFixed(2)} ‚ÇΩ
- üèÜ *–ü—Ä–æ—Ü–µ–Ω—Ç –ø–æ–±–µ–¥:* ${analytics.winRate.toFixed(2)}%
- ‚úÖ *–í—ã–∏–≥—Ä—ã—à–∏:* ${analytics.wonBetsCount} | ‚ùå *–ü—Ä–æ–∏–≥—Ä—ã—à–∏:* ${analytics.lostBetsCount}
- üìã *–í—Å–µ–≥–æ —Å—Ç–∞–≤–æ–∫:* ${analytics.betCount}`;
}

export function formatDetailedReportText(analytics: AnalyticsData): string {
    let text = formatShortReportText(analytics);
    text += '\n\n*–ü—Ä–∏–±—ã–ª—å –ø–æ –≤–∏–¥–∞–º —Å–ø–æ—Ä—Ç–∞:*\n';
    if(analytics.profitBySport.length > 0) {
        analytics.profitBySport.sort((a,b) => b.profit - a.profit).forEach(s => {
             const sign = s.profit >= 0 ? '+' : '';
             text += `- ${s.sport}: ${sign}${s.profit.toFixed(2)} ‚ÇΩ (ROI: ${s.roi.toFixed(1)}%)\n`;
        });
    } else {
        text += '_–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö_\n';
    }

    return text;
}

export function generateAnalyticsHtml(analytics: AnalyticsData): string {
    const styles = `<style>body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;background-color:#111827;color:#e5e7eb;padding:2rem}div{background-color:#1f2937;border:1px solid #374151;border-radius:0.75rem;padding:1.5rem;margin-bottom:1.5rem}h1,h2{color:white}h1{font-size:2rem}h2{border-bottom:1px solid #374151;padding-bottom:0.5rem;margin-top:2rem}ul{list-style:none;padding:0}li{display:flex;justify-content:space-between;padding:0.5rem 0;border-bottom:1px solid #374151}span:last-child{font-weight:600}.profit{color:#4ade80}.loss{color:#f87171}</style>`;
    
    let body = `<h1>üìä –û—Ç—á–µ—Ç BetDiary</h1>`;
    body += `<div><h2>–û–±—â–∞—è —Å–≤–æ–¥–∫–∞</h2><ul>`;
    body += `<li><span>–¢–µ–∫—É—â–∏–π –±–∞–Ω–∫</span><span>${analytics.bankroll.toFixed(2)} ‚ÇΩ</span></li>`;
    body += `<li><span>–û–±—â–∞—è –ø—Ä–∏–±—ã–ª—å</span><span class="${analytics.totalProfit >= 0 ? 'profit' : 'loss'}">${analytics.totalProfit.toFixed(2)} ‚ÇΩ</span></li>`;
    body += `<li><span>ROI</span><span class="${analytics.roi >= 0 ? 'profit' : 'loss'}">${analytics.roi.toFixed(2)}%</span></li>`;
    body += `<li><span>–ü—Ä–æ—Ü–µ–Ω—Ç –ø–æ–±–µ–¥</span><span>${analytics.winRate.toFixed(2)}%</span></li>`;
    body += `<li><span>–í—Å–µ–≥–æ —Å—Ç–∞–≤–æ–∫</span><span>${analytics.betCount}</span></li>`;
    body += `</ul></div>`;
    
    body += `<div><h2>–ü—Ä–∏–±—ã–ª—å –ø–æ —Å–ø–æ—Ä—Ç–∞–º</h2><ul>`;
    analytics.profitBySport.sort((a,b) => b.profit - a.profit).forEach(s => {
        body += `<li><span>${s.sport} (${s.count} —Å—Ç–∞–≤–æ–∫)</span><span class="${s.profit >= 0 ? 'profit' : 'loss'}">${s.profit.toFixed(2)} ‚ÇΩ (ROI: ${s.roi.toFixed(1)}%)</span></li>`;
    });
    body += `</ul></div>`;

    return `<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"><title>–û—Ç—á–µ—Ç BetDiary</title>${styles}</head><body>${body}</body></html>`;
}